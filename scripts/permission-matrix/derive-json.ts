#!/usr/bin/env tsx

import { writeFileSync, mkdirSync } from 'node:fs'
import { join, resolve, dirname } from 'node:path'
import { fileURLToPath } from 'node:url'

import { type AccessExpectation, type MatrixRow, permissionMatrix } from '../../src/security/permission-matrix.config'

const __dirname = fileURLToPath(new URL('.', import.meta.url))
const ROOT_DIR = resolve(__dirname, '../..')
const MATRIX_MD_FILE = join(ROOT_DIR, 'docs/security/permission-matrix.generated.md')
const TMP_JSON_FILE = join(ROOT_DIR, 'tmp/permission-matrix.json')

const ACCESS_LABEL: Record<AccessExpectation['type'], string> = {
  platform: 'Platform',
  anyone: 'Anyone',
  published: 'Published (approved)',
  conditional: 'Conditional',
}

const MARKDOWN_HEADER =
  `# Permission Matrix (Generated)\n\n` +
  `> âš ï¸ This file is generated by \`pnpm matrix:derive\` from \`src/security/permission-matrix.config.ts\`.\n` +
  `> Do not edit manually. Update the configuration instead.\n`

function formatAccess(access?: AccessExpectation): string {
  if (!access) return 'â€“'

  const label = ACCESS_LABEL[access.type]
  if (!access.details) {
    return label
  }

  const sanitizedDetails = access.details.replace(/\|/g, '\\|')
  return `${label}<br/><sub>${sanitizedDetails}</sub>`
}

function buildMarkdownTable(rows: MatrixRow[]): string {
  const hasReadVersions = rows.some((row) => row.operations.readVersions)
  const headers = ['Collection', 'Create', 'Read', 'Update', 'Delete', 'Admin']
  if (hasReadVersions) headers.push('Read&nbsp;Versions')

  const headerLine = `| ${headers.join(' | ')} |`
  const separatorLine = `| ${headers.map(() => '---').join(' | ')} |`

  const lines = rows.map((row) => {
    const cells = [
      `${row.displayName} \`(${row.slug})\``,
      formatAccess(row.operations.create),
      formatAccess(row.operations.read),
      formatAccess(row.operations.update),
      formatAccess(row.operations.delete),
      formatAccess(row.operations.admin),
    ]

    if (hasReadVersions) {
      cells.push(formatAccess(row.operations.readVersions))
    }

    return `| ${cells.join(' | ')} |`
  })

  return [headerLine, separatorLine, ...lines].join('\n')
}

function buildNotesSection(rows: MatrixRow[]): string {
  const noteLines = rows.filter((row) => Boolean(row.notes)).map((row) => `- **${row.displayName}**: ${row.notes}`)

  if (noteLines.length === 0) {
    return ''
  }

  return `\n\n## Notes\n\n${noteLines.join('\n')}`
}

async function main(): Promise<void> {
  console.log('ðŸ› ï¸  Generating permission matrix artifacts from config...')

  const rows = Object.values(permissionMatrix.collections)
  if (rows.length === 0) {
    console.error('âŒ No collections found in permissionMatrix configuration.')
    process.exit(1)
  }

  // Mode selection: default 'docs' writes docs artifacts; 'json' writes test JSON only to tmp/
  const mode = (process.argv[2] ?? 'docs').toLowerCase()

  if (mode === 'json') {
    // Ensure the tmp directory exists before writing the JSON snapshot
    mkdirSync(dirname(TMP_JSON_FILE), { recursive: true })
    writeFileSync(TMP_JSON_FILE, `${JSON.stringify(permissionMatrix, null, 2)}\n`)
    console.log(`âœ… Wrote JSON snapshot to ${TMP_JSON_FILE}`)
  } else {
    // 'docs' (default): write docs JSON + generated markdown

    const markdownTable = buildMarkdownTable(rows)
    const markdown = `${MARKDOWN_HEADER}\n${markdownTable}${buildNotesSection(rows)}\n`
    writeFileSync(MATRIX_MD_FILE, markdown)
    console.log(`âœ… Wrote generated markdown to ${MATRIX_MD_FILE}`)
  }

  console.log('\nðŸ“‹ Collections summarised:')
  for (const row of rows) {
    console.log(`   - ${row.slug} (${row.displayName})`)
  }

  console.log('\nâœ… Derivation completed successfully.')
}

main().catch((error) => {
  console.error('Fatal error:', error)
  process.exit(1)
})
