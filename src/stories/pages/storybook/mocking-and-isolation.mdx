import { Meta, Controls } from '@storybook/addon-docs/blocks'

<Meta title="Pages/Mocking & isolation" />

# Mocking & isolation

Stories must be isolated: no real navigation, fetch calls, or global app state. Use story-level mocks or decorators to keep story setup consistent and testable.

## Router mocking

Use a decorator when a component expects routing:

```tsx
const meta = {
  title: 'Templates/Header',
  decorators: [
    (Story) => (
      <RouterContext.Provider
        value={{
          push: () => Promise.resolve(true),
          replace: () => Promise.resolve(true),
          prefetch: () => Promise.resolve(),
        }}
      >
        <Story />
      </RouterContext.Provider>
    ),
  ],
}
```

## Fetch mocking

For components that call `fetch`, stub it in a decorator:

```tsx
const meta = {
  title: 'Organisms/Auth/ClinicRegistrationForm',
  decorators: [
    (Story) => {
      globalThis.fetch = async () =>
        new Response(JSON.stringify({ ok: true }), {
          status: 200,
          headers: { 'Content-Type': 'application/json' },
        })
      return <Story />
    },
  ],
}
```

## Module mocks

If a component imports a module that should be stubbed for Storybook, use `vi.mock` at the top of the story file.

## Rules of thumb

- Prefer story-level decorators over global mocks.
- Keep mocks deterministic and minimal.
- If a story crashes in tests due to missing providers, fix it in the story, not in global setup.
